üêû GUIDE COMPLET DE D√âBOGAGE LINUX üêû

üîß 1. OUTILS DE BASE
--------------------------------------------------
# Installation
sudo apt-get install gdb valgrind strace ltrace

# Exemple : Installation v√©rifi√©e
valgrind --version  # Doit afficher la version install√©e

üö© 2. COMPILATION AVEC FLAGS
--------------------------------------------------
# Commande type avec explications :
gcc -g3              # Infos de debug compl√®tes (pour gdb)
   -O0               # Pas d'optimisation (meilleur debug)
   -Wall             # Avertissements standards
   -Wextra           # Avertissements suppl√©mentaires
   -Werror           # Transforme les warnings en erreurs
   -fsanitize=address # D√©tecte erreurs m√©moire (buffer overflow...)
   -fsanitize=undefined # D√©tecte comportements ind√©finis
   -o mon_programme
   mon_programme.c

# Exemple concret :
# Fichier buggy.c (contient un bug intentionnel)
#include <stdio.h>

int main() {
    int tableau[5];
    tableau[5] = 42;  // D√©bordement !
    printf("Valeur : %d\n", tableau[5]);
    return 0;
}

# Compilation qui d√©tectera le bug :
gcc -g3 -O0 -Wall -Wextra -fsanitize=address buggy.c -o buggy

üêõ 3. GDB - EXEMPLE PRATIQUE
--------------------------------------------------
# Fichier exemple.c
#include <stdio.h>

void fonction_buggee() {
    int *p = NULL;
    *p = 42;  // Segmentation fault
}

int main() {
    printf("D√©but\n");
    fonction_buggee();
    printf("Fin\n");
    return 0;
}

# Commandes GDB :
gdb ./exemple
(gdb) break main	# Point d'arr√™t sur main()
(gdb) run			# Ex√©cution
(gdb) next			# Avancer pas √† pas
(gdb) backtrace  	# Voir la pile quand √ßa crash
(gdb) print p		# Examiner la variable
(gbd) list			# Affiche le code autour

üßπ 4. VALGRIND - EXEMPLE DE FUITE M√âMOIRE
--------------------------------------------------
# Fichier leak.c
#include <stdlib.h>

int main() {
    int *p = malloc(10 * sizeof(int));
    p[0] = 42;
    // Oubli de free(p);
    return 0;
}

# Analyse :
valgrind --leak-check=full ./leak

# Sortie typique :
==12345== 40 bytes in 1 blocks are definitely lost
==12345==    at 0x483B7F3: malloc (vg_replace_malloc.c:307)

üîç 5. STRACE/LTRACE - EXEMPLES
--------------------------------------------------
# strace (appels syst√®me)
strace -o trace.log ./mon_programme
# Exemple de sortie :
# open("fichier.txt", O_RDONLY) = -1 ENOENT (No such file...)

# ltrace (appels biblioth√®que)
ltrace -o lib.log ./mon_programme
# Exemple de sortie :
# malloc(10) = 0x12345678

üö® 6. SEGFAULT - PROC√âDURE
--------------------------------------------------
# Activer les core dumps
ulimit -c unlimited

# Ex√©cuter le programme
./mon_programme  # Crash -> g√©n√®re core

# Analyser le core
gdb ./mon_programme core
(gdb) backtrace

üí° 7. BONNES PRATIQUES - EXEMPLE
--------------------------------------------------
1. Reproduire le bug avec le minimum de code
2. Utiliser git bisect pour trouver le commit fautif :
   git bisect start
   git bisect bad    # Version actuelle bugg√©e
   git bisect good v1.0  # Derni√®re version stable
   # Test interm√©diaire...
   git bisect reset

üìù 8. FICHE M√âTHODOLOGIQUE
--------------------------------------------------
[Probl√®me] : Crash apr√®s ajout feature X
[Reproduction] : ./programme --option Y
[Outils] : gdb, valgrind
[Diagnostic] : Buffer overflow dans fonction Z
[Solution] : Agrandir buffer de 1024 √† 2048
[Validation] : Test unitaire ajout√©

üîÑ 9. SCRIPTS UTILES
--------------------------------------------------
# debug.sh - Automatisation
#!/bin/bash
gcc -g -fsanitize=address $1 -o ${1%.*} || exit 1
valgrind --leak-check=full ./${1%.*}
gdb -ex "break main" -ex "run" ./${1%.*}

# watch.sh - Recompilation auto
#!/bin/bash
while true; do
  inotifywait -e modify $1
  clear
  gcc -g $1 -o ${1%.*} && ./${1%.*}
done